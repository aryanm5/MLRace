<!DOCTYPE html>
<html lang="en-US">
<head>
<title>PuckWorld -- MyAI</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<meta name="author" content="Aryan M">
<meta name="description" content="Defend your sheep from the terrible zombies by placing towers strategically! NEW co-op mode!">
<meta name="keywords" content="Aryan M Games, Sheep Defense, Aryan M Games Sheep Defense, AryanM">
<meta name="language" content="English">
<link rel="icon" href="https://s3.amazonaws.com/aryanm/favicon.ico">
</head>
<body>
<center><font size="5"><strong>Milestone 4</strong></font><br>
Aryan Mittal<br>
(Explanation in README)<br><br>
<canvas id="canvas" style="background-color:lightskyblue;border:1px solid black;" width="500" height="500">Sorry, your browser doesn't support the canvas element. This won't work!</canvas><br><br>
<font face="monospace">Average Reward: <span id="averageReward">0</span><br>Total Score: <span id="totalScore">0</span><br><br>
Steps Per Tick: <input type="number" id="stepsPerTick" min="1" value="1" style="width:5em">
</font>
</center>
</body>
<script type="text/javascript" src="rl.js"></script>
<script>
var c = document.getElementById("canvas");
var ctx = c.getContext("2d");
c.width = 500;//window.innerWidth/1.3;
c.height = 500;//window.innerHeight - 30;
var WIDTH = c.width;
var HEIGHT = c.height;
var whichkey = [];
whichkey.length = 250;
whichkey.fill(false);
var interval;
var maxdist = Math.sqrt(2);
var averageRewardSpan = document.getElementById("averageReward");
var totalScoreSpan = document.getElementById("totalScore");
var gamestarted = false;

		//mouse
		document.onmousemove = function(e){
    	cursorX = e.pageX;
    	cursorY = e.pageY;
		}
        //circle
        function circle(x, y, r, stroke) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2*Math.PI);
            if(stroke == undefined) { ctx.fill(); } else { ctx.stroke(); }
     	    ctx.closePath(); //may be able to remove
        }
        //rectangle
        function rect(x, y, w, h) {
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.closePath();
        ctx.fill();
        }
		//line
		function line(x, y, x2, y2) {
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x2, y2);
		ctx.closePath();
		ctx.stroke();
		}
        //clear
        function clear() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        }
document.onkeydown = checkKey;
function checkKey(e) {
e = window.event;
whichkey[e.keyCode] = true;
if(gamestarted == false && e.ctrlKey == false && e.shiftKey == false && e.altKey == false) {
gamestarted = true;
}
}

var myagent = {
	x: Math.random(),
	y: Math.random(),
	rad: 0.05,
	xvel: 0,
	yvel: 0,
	velchange: 0.002,
	draw: function(action, reward) {
	// color agent by reward
	var r, g, b;
      var vv = reward + 0.5;
      var ms = 255.0;
      if(vv > 0) { g = 255; r = 255 - vv*ms; b = 255 - vv*ms; }
      if(vv < 0) { g = 255 + vv*ms; r = 255; b = 255 + vv*ms; }
      var vcol = 'rgb('+Math.floor(r)+','+Math.floor(g)+','+Math.floor(b)+')';
		ctx.fillStyle = "black";
		circle(this.x*WIDTH, this.y*HEIGHT, this.rad*WIDTH+1, true);
		ctx.fillStyle = vcol;
		circle(this.x*WIDTH, this.y*HEIGHT, this.rad*WIDTH);
		
	ctx.fillStyle = "black";
	ctx.lineWidth = 3;
	if(action == 0) {
		arrow(this.x*WIDTH, this.y*HEIGHT, this.x*WIDTH, this.y*HEIGHT - this.rad*HEIGHT/1.5);
	} else if(action == 1) {
		arrow(this.x*WIDTH, this.y*HEIGHT, this.x*WIDTH, this.y*HEIGHT + this.rad*HEIGHT/1.5);
	} else if(action == 2) {
		arrow(this.x*WIDTH, this.y*HEIGHT, this.x*WIDTH - this.rad*WIDTH/1.5, this.y*HEIGHT);
	} else if(action == 3) {
		arrow(this.x*WIDTH, this.y*HEIGHT, this.x*WIDTH + this.rad*WIDTH/1.5, this.y*HEIGHT);
	}
	}
};

var red = {
	x: Math.random(),
	y: Math.random(),
	smallrad: 0.05,
	bigrad: 0.25,
	speed: 0.0003,
	step: {x: 0, y: 0}, //step.x and step.y
	color: "rgb(255, 0, 0, 0.3)",
	draw: function() {
	ctx.fillStyle = "black";
		ctx.fillStyle = this.color;
		circle(this.x*WIDTH, this.y*HEIGHT, this.bigrad*WIDTH); //make this fainter and draw smaller circle on top, not faint
	}
};
var green = {
	x: Math.random(),
	y: Math.random(),
	rad: 0.05,
	color: "green",
	draw: function() {
		ctx.fillStyle = this.color;
		circle(this.x*WIDTH, this.y*HEIGHT, this.rad*WIDTH);
	}
};

var env = {};
env.getNumStates = function() { return 8; }
env.getMaxNumActions = function() { return 5; }

// create the agent, yay!
var spec = {}
spec.update = 'qlearn'; // qlearn | sarsa
spec.gamma = 0.9; // discount factor, [0, 1)
spec.epsilon = 0.2; // initial epsilon for epsilon-greedy policy, [0, 1)
spec.alpha = 0.01; // value function learning rate
spec.experience_add_every = 10; // number of time steps before we add another experience to replay memory
spec.experience_size = 5000; // size of experience replay memory
spec.learning_steps_per_iteration = 20;
spec.tderror_clamp = 1.0; // for robustness
spec.num_hidden_units = 100 // number of neurons in hidden layer

agent = new RL.DQNAgent(env, spec);

var s = []; //agent x, y; agent velocity vx, vy; green x, y; red x, y
var reward;
var frame = 0;
var stepsPerTick = 10; //higher means faster but choppier 1 good
var totalScore = 0;
var averageReward = 0;

setInterval(function(){ // start the learning loop
var action;
for(var i = 0; i < stepsPerTick; ++i) {
	s = [myagent.x, myagent.y, myagent.xvel, myagent.yvel, green.x, green.y, red.x, red.y];
	action = agent.act(s); // s is an array of length 8, action is 0, 1, 2, or 3, or 4
	// execute action in environment and get the reward
  
  myagent.xvel *= 0.95; //dampener
  myagent.yvel *= 0.95;
  
  if(action === 0) {
	myagent.yvel -= myagent.velchange;
  } else if(action === 1) {
	myagent.yvel += myagent.velchange;
  } else if(action === 2) {
	myagent.xvel -= myagent.velchange;
  } else if(action === 3) {
	myagent.xvel += myagent.velchange;
  }
  
  if(whichkey[38]) { player.yvel -= player.velchange; } if(whichkey[40]) { player.yvel += player.velchange; }
  if(whichkey[37]) { player.xvel -= player.velchange; } if(whichkey[39]) { player.xvel += player.velchange; }

	myagent.x += myagent.xvel;
	myagent.y += myagent.yvel;
	
	//bounce and border conditions
	var border = 0.05;
	if(myagent.x < 0.05) {
		myagent.xvel *= -0.5; //bounce!
		myagent.x = 0.05;
	}
	if(myagent.x > 0.95) {
		myagent.xvel *= -0.5;
		myagent.x = 0.95;
	}
	if(myagent.y < 0.05) {
		myagent.yvel *= -0.5;
		myagent.y = 0.05;
	}
	if(myagent.y > 0.95) {
		myagent.yvel *= -0.5;
		myagent.y = 0.95;
	}
  
  red.step = normalize({x: myagent.x - red.x, y: myagent.y - red.y});
  red.x += red.step.x*red.speed;
  red.y += red.step.y*red.speed;
  
  //move green every few seconds
  if(frame % 2000 == 0) {
	green.x = Math.random();
	green.y = Math.random();
  }
  
  reward = calculateReward(action);
  
  totalScore += reward;
  averageReward = totalScore/frame;
  agent.learn(reward); // the agent improves its Q,policy,model, etc. reward is a float
  frame++;
  }
  
  clear();
  red.draw();
  green.draw();
  myagent.draw(action, reward);
  
  averageRewardSpan.innerHTML = averageReward.toFixed(3);
  totalScoreSpan.innerHTML = totalScore.toFixed(3);
}, 0);

//FUNCTIONS
function calculateReward(action) {
	var reward = 0;
	var reddist = Math.sqrt((myagent.x-red.x)*(myagent.x-red.x) + (myagent.y-red.y)*(myagent.y-red.y));
	var greendist = Math.sqrt((myagent.x-green.x)*(myagent.x-green.x) + (myagent.y-green.y)*(myagent.y-green.y));
	reward = 0.5-greendist;
	if(reddist <= red.bigrad) {
		reward += 2*(reddist - red.bigrad)/red.bigrad;
	}
	if(action === 4) { reward += 0.05; }
	
	return reward;
}
function arrow(fromx, fromy, tox, toy) {
  var headlen = 0.02*WIDTH; // length of head in pixels
  var dx = tox - fromx;
  var dy = toy - fromy;
  var angle = Math.atan2(dy, dx);
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
  ctx.stroke();
}

function normalize(v) {
    var length = Math.sqrt(v.x * v.x + v.y * v.y);
    return {x: v.x / length, y: v.y / length};
}

document.getElementById("stepsPerTick").addEventListener("input", function (e) {
    stepsPerTick = Number(this.value);
});
</script>
</html>